
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for api/dist/frontend/polyfills.e89f517c8981cf68.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../prettify.css" />
    <link rel="stylesheet" href="../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../index.html">All files</a> / <a href="index.html">api/dist/frontend</a> polyfills.e89f517c8981cf68.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/978</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/1048</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/236</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";<span class="cstat-no" title="statement not covered" >(self.webpackChunkfrontend=self.webpackChunkfrontend||[]).push([[429],{8782:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e){const n=<span class="cstat-no" title="statement not covered" >e.performance;</span>function <span class="fstat-no" title="function not covered" >i(</span>I){<span class="cstat-no" title="statement not covered" >n&amp;&amp;n.mark&amp;&amp;n.mark(I)}</span>function <span class="fstat-no" title="function not covered" >r(</span>I,p){<span class="cstat-no" title="statement not covered" >n&amp;&amp;n.measure&amp;&amp;n.measure(I,p)}<span class="cstat-no" title="statement not covered" ></span>i("Zone");c</span>onst c=<span class="cstat-no" title="statement not covered" >e.__Zone_symbol_prefix||"__zone_symbol__";</span>function <span class="fstat-no" title="function not covered" >u(</span>I){<span class="cstat-no" title="statement not covered" >return c+I}</span>const f=<span class="cstat-no" title="statement not covered" >!0===e[u("forceDuplicateZoneCheck")];<span class="cstat-no" title="statement not covered" ></span>if(e.Zone){<span class="cstat-no" title="statement not covered" >if(f||"function"!=typeof e.Zone.__symbol__)<span class="cstat-no" title="statement not covered" >throw new Error("Zone already loaded.");<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.Zone}</span>l</span>et _=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{class I{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,o){<span class="cstat-no" title="statement not covered" >this._parent=t,this._name=o?o.name||"unnamed":"&lt;root&gt;",this._properties=o&amp;&amp;o.properties||{},this._zoneDelegate=new T(this,this._parent&amp;&amp;this._parent._zoneDelegate,o)}<span class="fstat-no" title="function not covered" ></span>st</span>atic assertZonePatched(){<span class="cstat-no" title="statement not covered" >if(e.Promise!==J.ZoneAwarePromise)<span class="cstat-no" title="statement not covered" >throw new Error("Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)")}<span class="fstat-no" title="function not covered" ></span></span>st</span>atic get root(){let t=<span class="cstat-no" title="statement not covered" >I.current;<span class="cstat-no" title="statement not covered" ></span>for(;t.parent;)<span class="cstat-no" title="statement not covered" >t=t.parent;<span class="cstat-no" title="statement not covered" >r</span></span>eturn t}<span class="fstat-no" title="function not covered" ></span>st</span>atic get current(){<span class="cstat-no" title="statement not covered" >return G.zone}<span class="fstat-no" title="function not covered" ></span>st</span>atic get currentTask(){<span class="cstat-no" title="statement not covered" >return te}<span class="fstat-no" title="function not covered" ></span>st</span>atic __load_patch(t,o,y=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(J.hasOwnProperty(t)){<span class="cstat-no" title="statement not covered" >if(!y&amp;&amp;f)<span class="cstat-no" title="statement not covered" >throw Error("Already loaded patch: "+t)}</span></span>else <span class="cstat-no" title="statement not covered" >if(!e["__Zone_disable_"+t]){const P=<span class="cstat-no" title="statement not covered" >"Zone:"+t;<span class="cstat-no" title="statement not covered" ></span>i(P),J[t]=o(e,I,le),r(P,P)}</span>}<span class="fstat-no" title="function not covered" ></span></span>ge</span>t parent(){<span class="cstat-no" title="statement not covered" >return this._parent}<span class="fstat-no" title="function not covered" ></span>ge</span>t name(){<span class="cstat-no" title="statement not covered" >return this._name}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){const o=<span class="cstat-no" title="statement not covered" >this.getZoneWith(t);<span class="cstat-no" title="statement not covered" ></span>if(o)<span class="cstat-no" title="statement not covered" >return o._properties[t]}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tZoneWith(t){let o=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(;o;){<span class="cstat-no" title="statement not covered" >if(o._properties.hasOwnProperty(t))<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >o</span></span>=o._parent}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}<span class="fstat-no" title="function not covered" ></span>fo</span>rk(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >throw new Error("ZoneSpec required!");<span class="cstat-no" title="statement not covered" >r</span></span>eturn this._zoneDelegate.fork(this,t)}<span class="fstat-no" title="function not covered" ></span>wr</span>ap(t,o){<span class="cstat-no" title="statement not covered" >if("function"!=typeof t)<span class="cstat-no" title="statement not covered" >throw new Error("Expecting function got: "+t);c</span></span>onst y=<span class="cstat-no" title="statement not covered" >this._zoneDelegate.intercept(this,t,o),</span>P=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return P.runGuarded(y,this,arguments,o)}</span>}<span class="fstat-no" title="function not covered" ></span>ru</span>n(t,o,y,P){<span class="cstat-no" title="statement not covered" >G={parent:G,zone:this};<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return this._zoneDelegate.invoke(this,t,o,y,P)}</span>finally{<span class="cstat-no" title="statement not covered" >G=G.parent}</span>}<span class="fstat-no" title="function not covered" ></span>ru</span>nGuarded(t,o=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>y,P){<span class="cstat-no" title="statement not covered" >G={parent:G,zone:this};<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return this._zoneDelegate.invoke(this,t,o,y,P)}</span>catch(K){<span class="cstat-no" title="statement not covered" >if(this._zoneDelegate.handleError(this,K))<span class="cstat-no" title="statement not covered" >throw K}</span></span>}</span>finally{<span class="cstat-no" title="statement not covered" >G=G.parent}</span>}<span class="fstat-no" title="function not covered" ></span>ru</span>nTask(t,o,y){<span class="cstat-no" title="statement not covered" >if(t.zone!=this)<span class="cstat-no" title="statement not covered" >throw new Error("A task can only be run in the zone of creation! (Creation: "+(t.zone||z).name+"; Execution: "+this.name+")");<span class="cstat-no" title="statement not covered" >i</span></span>f(t.state===j&amp;&amp;(t.type===R||t.type===M))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst P=<span class="cstat-no" title="statement not covered" >t.state!=X;<span class="cstat-no" title="statement not covered" ></span>P&amp;&amp;t._transitionTo(X,O),t.runCount++;c</span>onst K=<span class="cstat-no" title="statement not covered" >te;<span class="cstat-no" title="statement not covered" ></span>te=t,G={parent:G,zone:this};<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >t.type==M&amp;&amp;t.data&amp;&amp;!t.data.isPeriodic&amp;&amp;(t.cancelFn=void 0);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return this._zoneDelegate.invokeTask(this,t,o,y)}</span>catch(l){<span class="cstat-no" title="statement not covered" >if(this._zoneDelegate.handleError(this,l))<span class="cstat-no" title="statement not covered" >throw l}</span></span>}</span>finally{<span class="cstat-no" title="statement not covered" >t.state!==j&amp;&amp;t.state!==Y&amp;&amp;(t.type==R||t.data&amp;&amp;t.data.isPeriodic?P&amp;&amp;t._transitionTo(O,X):(t.runCount=0,this._updateTaskCount(t,-1),P&amp;&amp;t._transitionTo(j,X,j))),G=G.parent,te=K}</span>}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleTask(t){<span class="cstat-no" title="statement not covered" >if(t.zone&amp;&amp;t.zone!==this){let y=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>for(;y;){<span class="cstat-no" title="statement not covered" >if(y===t.zone)<span class="cstat-no" title="statement not covered" >throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${t.zone.name}`);<span class="cstat-no" title="statement not covered" >y</span></span>=y.parent}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>._transitionTo(q,j);c</span>onst o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t._zoneDelegates=o,t._zone=this;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >t=this._zoneDelegate.scheduleTask(this,t)}</span>catch(y){<span class="cstat-no" title="statement not covered" >throw t._transitionTo(Y,q,j),this._zoneDelegate.handleError(this,y),y}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t._zoneDelegates===o&amp;&amp;this._updateTaskCount(t,1),t.state==q&amp;&amp;t._transitionTo(O,q),t}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleMicroTask(t,o,y,P){<span class="cstat-no" title="statement not covered" >return this.scheduleTask(new m(v,t,o,y,P,void 0))}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleMacroTask(t,o,y,P,K){<span class="cstat-no" title="statement not covered" >return this.scheduleTask(new m(M,t,o,y,P,K))}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleEventTask(t,o,y,P,K){<span class="cstat-no" title="statement not covered" >return this.scheduleTask(new m(R,t,o,y,P,K))}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelTask(t){<span class="cstat-no" title="statement not covered" >if(t.zone!=this)<span class="cstat-no" title="statement not covered" >throw new Error("A task can only be cancelled in the zone of creation! (Creation: "+(t.zone||z).name+"; Execution: "+this.name+")");<span class="cstat-no" title="statement not covered" >t</span></span>._transitionTo(A,O,X);<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >this._zoneDelegate.cancelTask(this,t)}</span>catch(o){<span class="cstat-no" title="statement not covered" >throw t._transitionTo(Y,A),this._zoneDelegate.handleError(this,o),o}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._updateTaskCount(t,-1),t._transitionTo(j,A),t.runCount=0,t}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateTaskCount(t,o){const y=<span class="cstat-no" title="statement not covered" >t._zoneDelegates;<span class="cstat-no" title="statement not covered" ></span>-1==o&amp;&amp;(t._zoneDelegates=null);<span class="cstat-no" title="statement not covered" >f</span>or(let P=<span class="cstat-no" title="statement not covered" >0;</span>P&lt;y.length;P++)<span class="cstat-no" title="statement not covered" >y[P]._updateTaskCount(t.type,o)}</span></span>}<span class="cstat-no" title="statement not covered" >return I.__symbol__=u,I}</span>)();</span>const g=<span class="cstat-no" title="statement not covered" >{name:"",onHasTask:<span class="fstat-no" title="function not covered" >(I</span>,p,t,o)=&gt;<span class="cstat-no" title="statement not covered" >I.hasTask(t,o),</span>onScheduleTask:<span class="fstat-no" title="function not covered" >(I</span>,p,t,o)=&gt;<span class="cstat-no" title="statement not covered" >I.scheduleTask(t,o),</span>onInvokeTask:<span class="fstat-no" title="function not covered" >(I</span>,p,t,o,y,P)=&gt;<span class="cstat-no" title="statement not covered" >I.invokeTask(t,o,y,P),</span>onCancelTask:<span class="fstat-no" title="function not covered" >(I</span>,p,t,o)=&gt;<span class="cstat-no" title="statement not covered" >I.cancelTask(t,o)}</span>;</span>class T{<span class="fstat-no" title="function not covered" >co</span>nstructor(p,t,o){<span class="cstat-no" title="statement not covered" >this._taskCounts={microTask:0,macroTask:0,eventTask:0},this.zone=p,this._parentDelegate=t,this._forkZS=o&amp;&amp;(o&amp;&amp;o.onFork?o:t._forkZS),this._forkDlgt=o&amp;&amp;(o.onFork?t:t._forkDlgt),this._forkCurrZone=o&amp;&amp;(o.onFork?this.zone:t._forkCurrZone),this._interceptZS=o&amp;&amp;(o.onIntercept?o:t._interceptZS),this._interceptDlgt=o&amp;&amp;(o.onIntercept?t:t._interceptDlgt),this._interceptCurrZone=o&amp;&amp;(o.onIntercept?this.zone:t._interceptCurrZone),this._invokeZS=o&amp;&amp;(o.onInvoke?o:t._invokeZS),this._invokeDlgt=o&amp;&amp;(o.onInvoke?t:t._invokeDlgt),this._invokeCurrZone=o&amp;&amp;(o.onInvoke?this.zone:t._invokeCurrZone),this._handleErrorZS=o&amp;&amp;(o.onHandleError?o:t._handleErrorZS),this._handleErrorDlgt=o&amp;&amp;(o.onHandleError?t:t._handleErrorDlgt),this._handleErrorCurrZone=o&amp;&amp;(o.onHandleError?this.zone:t._handleErrorCurrZone),this._scheduleTaskZS=o&amp;&amp;(o.onScheduleTask?o:t._scheduleTaskZS),this._scheduleTaskDlgt=o&amp;&amp;(o.onScheduleTask?t:t._scheduleTaskDlgt),this._scheduleTaskCurrZone=o&amp;&amp;(o.onScheduleTask?this.zone:t._scheduleTaskCurrZone),this._invokeTaskZS=o&amp;&amp;(o.onInvokeTask?o:t._invokeTaskZS),this._invokeTaskDlgt=o&amp;&amp;(o.onInvokeTask?t:t._invokeTaskDlgt),this._invokeTaskCurrZone=o&amp;&amp;(o.onInvokeTask?this.zone:t._invokeTaskCurrZone),this._cancelTaskZS=o&amp;&amp;(o.onCancelTask?o:t._cancelTaskZS),this._cancelTaskDlgt=o&amp;&amp;(o.onCancelTask?t:t._cancelTaskDlgt),this._cancelTaskCurrZone=o&amp;&amp;(o.onCancelTask?this.zone:t._cancelTaskCurrZone),this._hasTaskZS=null,this._hasTaskDlgt=null,this._hasTaskDlgtOwner=null,this._hasTaskCurrZone=null;c</span>onst y=<span class="cstat-no" title="statement not covered" >o&amp;&amp;o.onHasTask;<span class="cstat-no" title="statement not covered" ></span>(y||t&amp;&amp;t._hasTaskZS)&amp;&amp;(this._hasTaskZS=y?o:g,this._hasTaskDlgt=t,this._hasTaskDlgtOwner=this,this._hasTaskCurrZone=p,o.onScheduleTask||(this._scheduleTaskZS=g,this._scheduleTaskDlgt=t,this._scheduleTaskCurrZone=this.zone),o.onInvokeTask||(this._invokeTaskZS=g,this._invokeTaskDlgt=t,this._invokeTaskCurrZone=this.zone),o.onCancelTask||(this._cancelTaskZS=g,this._cancelTaskDlgt=t,this._cancelTaskCurrZone=this.zone))}<span class="fstat-no" title="function not covered" ></span>fo</span>rk(p,t){<span class="cstat-no" title="statement not covered" >return this._forkZS?this._forkZS.onFork(this._forkDlgt,this.zone,p,t):new _(p,t)}<span class="fstat-no" title="function not covered" ></span>in</span>tercept(p,t,o){<span class="cstat-no" title="statement not covered" >return this._interceptZS?this._interceptZS.onIntercept(this._interceptDlgt,this._interceptCurrZone,p,t,o):t}<span class="fstat-no" title="function not covered" ></span>in</span>voke(p,t,o,y,P){<span class="cstat-no" title="statement not covered" >return this._invokeZS?this._invokeZS.onInvoke(this._invokeDlgt,this._invokeCurrZone,p,t,o,y,P):t.apply(o,y)}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleError(p,t){<span class="cstat-no" title="statement not covered" >return!this._handleErrorZS||this._handleErrorZS.onHandleError(this._handleErrorDlgt,this._handleErrorCurrZone,p,t)}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleTask(p,t){let o=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(this._scheduleTaskZS)<span class="cstat-no" title="statement not covered" >this._hasTaskZS&amp;&amp;o._zoneDelegates.push(this._hasTaskDlgtOwner),o=this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt,this._scheduleTaskCurrZone,p,t),o||(o=t);e</span>lse <span class="cstat-no" title="statement not covered" >if(t.scheduleFn)<span class="cstat-no" title="statement not covered" >t.scheduleFn(t);e</span>lse{<span class="cstat-no" title="statement not covered" >if(t.type!=v)<span class="cstat-no" title="statement not covered" >throw new Error("Task is missing scheduleFn.");<span class="cstat-no" title="statement not covered" >d</span></span>(t)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn o}<span class="fstat-no" title="function not covered" ></span>in</span>vokeTask(p,t,o,y){<span class="cstat-no" title="statement not covered" >return this._invokeTaskZS?this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt,this._invokeTaskCurrZone,p,t,o,y):t.callback.apply(o,y)}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelTask(p,t){let o;<span class="cstat-no" title="statement not covered" >if(this._cancelTaskZS)<span class="cstat-no" title="statement not covered" >o=this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt,this._cancelTaskCurrZone,p,t);e</span>lse{<span class="cstat-no" title="statement not covered" >if(!t.cancelFn)<span class="cstat-no" title="statement not covered" >throw Error("Task is not cancelable");<span class="cstat-no" title="statement not covered" >o</span></span>=t.cancelFn(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}<span class="fstat-no" title="function not covered" ></span>ha</span>sTask(p,t){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this._hasTaskZS&amp;&amp;this._hasTaskZS.onHasTask(this._hasTaskDlgt,this._hasTaskCurrZone,p,t)}</span>catch(o){<span class="cstat-no" title="statement not covered" >this.handleError(p,o)}</span>}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateTaskCount(p,t){const o=<span class="cstat-no" title="statement not covered" >this._taskCounts,</span>y=<span class="cstat-no" title="statement not covered" >o[p],</span>P=<span class="cstat-no" title="statement not covered" >o[p]=y+t;<span class="cstat-no" title="statement not covered" ></span>if(P&lt;0)<span class="cstat-no" title="statement not covered" >throw new Error("More tasks executed then were scheduled.");<span class="cstat-no" title="statement not covered" >0</span></span>!=y&amp;&amp;0!=P||this.hasTask(this.zone,{microTask:o.microTask&gt;0,macroTask:o.macroTask&gt;0,eventTask:o.eventTask&gt;0,change:p})}</span>}class m{<span class="fstat-no" title="function not covered" >co</span>nstructor(p,t,o,y,P,K){<span class="cstat-no" title="statement not covered" >if(this._zone=null,this.runCount=0,this._zoneDelegates=null,this._state="notScheduled",this.type=p,this.source=t,this.data=y,this.scheduleFn=P,this.cancelFn=K,!o)<span class="cstat-no" title="statement not covered" >throw new Error("callback is not defined");<span class="cstat-no" title="statement not covered" >t</span></span>his.callback=o;c</span>onst l=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this.invoke=p===R&amp;&amp;y&amp;&amp;y.useG?m.invokeTask:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return m.invokeTask.call(e,l,this,arguments)}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>atic invokeTask(p,t,o){<span class="cstat-no" title="statement not covered" >p||(p=this),re++;<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >return p.runCount++,p.zone.runTask(p,t,o)}</span>finally{<span class="cstat-no" title="statement not covered" >1==re&amp;&amp;L(),re--}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t zone(){<span class="cstat-no" title="statement not covered" >return this._zone}<span class="fstat-no" title="function not covered" ></span>ge</span>t state(){<span class="cstat-no" title="statement not covered" >return this._state}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelScheduleRequest(){<span class="cstat-no" title="statement not covered" >this._transitionTo(j,q)}<span class="fstat-no" title="function not covered" ></span>_t</span>ransitionTo(p,t,o){<span class="cstat-no" title="statement not covered" >if(this._state!==t&amp;&amp;this._state!==o)<span class="cstat-no" title="statement not covered" >throw new Error(`${this.type} '${this.source}': can not transition to '${p}', expecting state '${t}'${o?" or '"+o+"'":""}, was '${this._state}'.`);<span class="cstat-no" title="statement not covered" >t</span></span>his._state=p,p==j&amp;&amp;(this._zoneDelegates=null)}<span class="fstat-no" title="function not covered" ></span>to</span>String(){<span class="cstat-no" title="statement not covered" >return this.data&amp;&amp;void 0!==this.data.handleId?this.data.handleId.toString():Object.prototype.toString.call(this)}<span class="fstat-no" title="function not covered" ></span>to</span>JSON(){<span class="cstat-no" title="statement not covered" >return{type:this.type,state:this.state,source:this.source,zone:this.zone.name,runCount:this.runCount}}</span>}const S=<span class="cstat-no" title="statement not covered" >u("setTimeout"),</span>D=<span class="cstat-no" title="statement not covered" >u("Promise"),</span>Z=<span class="cstat-no" title="statement not covered" >u("then");</span>let E,B=<span class="cstat-no" title="statement not covered" >[],</span>V=<span class="cstat-no" title="statement not covered" >!1;</span>function <span class="fstat-no" title="function not covered" >d(</span>I){<span class="cstat-no" title="statement not covered" >if(0===re&amp;&amp;0===B.length)<span class="cstat-no" title="statement not covered" >if(E||e[D]&amp;&amp;(E=e[D].resolve(0)),E){let p=<span class="cstat-no" title="statement not covered" >E[Z];<span class="cstat-no" title="statement not covered" ></span>p||(p=E.then),p.call(E,L)}</span>else <span class="cstat-no" title="statement not covered" >e[S](L,0);<span class="cstat-no" title="statement not covered" >I</span></span></span>&amp;&amp;B.push(I)}</span>function <span class="fstat-no" title="function not covered" >L(</span>){<span class="cstat-no" title="statement not covered" >if(!V){<span class="cstat-no" title="statement not covered" >for(V=!0;B.length;){const I=<span class="cstat-no" title="statement not covered" >B;<span class="cstat-no" title="statement not covered" ></span>B=[];<span class="cstat-no" title="statement not covered" >f</span>or(let p=<span class="cstat-no" title="statement not covered" >0;</span>p&lt;I.length;p++){const t=<span class="cstat-no" title="statement not covered" >I[p];<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >t.zone.runTask(t,null,null)}</span>catch(o){<span class="cstat-no" title="statement not covered" >le.onUnhandledError(o)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>l</span>e.microtaskDrainDone(),V=!1}</span>}</span>const z=<span class="cstat-no" title="statement not covered" >{name:"NO ZONE"},</span>j=<span class="cstat-no" title="statement not covered" >"notScheduled",</span>q=<span class="cstat-no" title="statement not covered" >"scheduling",</span>O=<span class="cstat-no" title="statement not covered" >"scheduled",</span>X=<span class="cstat-no" title="statement not covered" >"running",</span>A=<span class="cstat-no" title="statement not covered" >"canceling",</span>Y=<span class="cstat-no" title="statement not covered" >"unknown",</span>v=<span class="cstat-no" title="statement not covered" >"microTask",</span>M=<span class="cstat-no" title="statement not covered" >"macroTask",</span>R=<span class="cstat-no" title="statement not covered" >"eventTask",</span>J=<span class="cstat-no" title="statement not covered" >{},</span>le=<span class="cstat-no" title="statement not covered" >{symbol:u,currentZoneFrame:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >G,</span>onUnhandledError:F,microtaskDrainDone:F,scheduleMicroTask:d,showUncaughtError:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!_[u("ignoreConsoleErrorUncaughtError")],</span>patchEventTarget:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[],</span>patchOnProperties:F,patchMethod:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>bindArguments:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[],</span>patchThen:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>patchMacroTask:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>patchEventPrototype:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>isIEOrEdge:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!1,</span>getGlobalObjects:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},ObjectDefineProperty:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>ObjectGetOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},ObjectCreate:<span class="fstat-no" title="function not covered" >()</span>=&gt;{},ArraySlice:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[],</span>patchClass:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>wrapWithCurrentZone:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>filterProperties:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[],</span>attachOriginToPatched:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>_redefineProperty:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F,</span>patchCallbacks:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F}</span>;</span>let G=<span class="cstat-no" title="statement not covered" >{parent:null,zone:new _(null,null)},</span>te=<span class="cstat-no" title="statement not covered" >null,</span>re=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >F(</span>){}<span class="cstat-no" title="statement not covered" >r("Zone","Zone"),e.Zone=_}</span>("undefined"!=typeof window&amp;&amp;window||"undefined"!=typeof self&amp;&amp;self||global);c</span>onst ue=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor,</span>he=<span class="cstat-no" title="statement not covered" >Object.defineProperty,</span>de=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf,</span>Be=<span class="cstat-no" title="statement not covered" >Object.create,</span>ut=<span class="cstat-no" title="statement not covered" >Array.prototype.slice,</span>Se=<span class="cstat-no" title="statement not covered" >"addEventListener",</span>Oe=<span class="cstat-no" title="statement not covered" >"removeEventListener",</span>Ze=<span class="cstat-no" title="statement not covered" >Zone.__symbol__(Se),</span>Ie=<span class="cstat-no" title="statement not covered" >Zone.__symbol__(Oe),</span>se=<span class="cstat-no" title="statement not covered" >"true",</span>ie=<span class="cstat-no" title="statement not covered" >"false",</span>ke=<span class="cstat-no" title="statement not covered" >Zone.__symbol__("");</span>function <span class="fstat-no" title="function not covered" >Le(</span>e,n){<span class="cstat-no" title="statement not covered" >return Zone.current.wrap(e,n)}</span>function <span class="fstat-no" title="function not covered" >Me(</span>e,n,i,r,c){<span class="cstat-no" title="statement not covered" >return Zone.current.scheduleMacroTask(e,n,i,r,c)}</span>const x=<span class="cstat-no" title="statement not covered" >Zone.__symbol__,</span>Pe=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof window,</span>pe=<span class="cstat-no" title="statement not covered" >Pe?window:void 0,</span>$=<span class="cstat-no" title="statement not covered" >Pe&amp;&amp;pe||"object"==typeof self&amp;&amp;self||global,</span>ht=<span class="cstat-no" title="statement not covered" >[null];</span>function <span class="fstat-no" title="function not covered" >Ae(</span>e,n){<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >e.length-1;</span>i&gt;=0;i--)<span class="cstat-no" title="statement not covered" >"function"==typeof e[i]&amp;&amp;(e[i]=Le(e[i],n+"_"+i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Fe(</span>e){<span class="cstat-no" title="statement not covered" >return!e||!1!==e.writable&amp;&amp;!("function"==typeof e.get&amp;&amp;void 0===e.set)}</span>const Ue=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof WorkerGlobalScope&amp;&amp;self instanceof WorkerGlobalScope,</span>Re=<span class="cstat-no" title="statement not covered" >!("nw"in $)&amp;&amp;void 0!==$.process&amp;&amp;"[object process]"==={}.toString.call($.process),</span>je=<span class="cstat-no" title="statement not covered" >!Re&amp;&amp;!Ue&amp;&amp;!(!Pe||!pe.HTMLElement),</span>We=<span class="cstat-no" title="statement not covered" >void 0!==$.process&amp;&amp;"[object process]"==={}.toString.call($.process)&amp;&amp;!Ue&amp;&amp;!(!Pe||!pe.HTMLElement),</span>Ce=<span class="cstat-no" title="statement not covered" >{},</span>qe=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(!(e=e||$.event))<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >Ce[e.type];<span class="cstat-no" title="statement not covered" ></span>n||(n=Ce[e.type]=x("ON_PROPERTY"+e.type));c</span>onst i=<span class="cstat-no" title="statement not covered" >this||e.target||$,</span>r=<span class="cstat-no" title="statement not covered" >i[n];</span>let c;<span class="cstat-no" title="statement not covered" >if(je&amp;&amp;i===pe&amp;&amp;"error"===e.type){const u=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>c=r&amp;&amp;r.call(this,u.message,u.filename,u.lineno,u.colno,u.error),!0===c&amp;&amp;e.preventDefault()}</span>else <span class="cstat-no" title="statement not covered" >c=r&amp;&amp;r.apply(this,arguments),null!=c&amp;&amp;!c&amp;&amp;e.preventDefault();<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}</span>;</span>function <span class="fstat-no" title="function not covered" >Xe(</span>e,n,i){let r=<span class="cstat-no" title="statement not covered" >ue(e,n);<span class="cstat-no" title="statement not covered" ></span>if(!r&amp;&amp;i&amp;&amp;ue(i,n)&amp;&amp;(r={enumerable:!0,configurable:!0}),!r||!r.configurable)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >x("on"+n+"patched");<span class="cstat-no" title="statement not covered" ></span>if(e.hasOwnProperty(c)&amp;&amp;e[c])<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >d</span></span>elete r.writable,delete r.value;c</span>onst u=<span class="cstat-no" title="statement not covered" >r.get,</span>f=<span class="cstat-no" title="statement not covered" >r.set,</span>_=<span class="cstat-no" title="statement not covered" >n.substr(2);</span>let g=<span class="cstat-no" title="statement not covered" >Ce[_];<span class="cstat-no" title="statement not covered" ></span>g||(g=Ce[_]=x("ON_PROPERTY"+_)),r.set=<span class="fstat-no" title="function not covered" >fu</span>nction(T){let m=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>!m&amp;&amp;e===$&amp;&amp;(m=$),m&amp;&amp;(m[g]&amp;&amp;m.removeEventListener(_,qe),f&amp;&amp;f.apply(m,ht),"function"==typeof T?(m[g]=T,m.addEventListener(_,qe,!1)):m[g]=null)}</span>,r.get=<span class="fstat-no" title="function not covered" >fu</span>nction(){let T=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!T&amp;&amp;e===$&amp;&amp;(T=$),!T)<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst m=<span class="cstat-no" title="statement not covered" >T[g];<span class="cstat-no" title="statement not covered" ></span>if(m)<span class="cstat-no" title="statement not covered" >return m;<span class="cstat-no" title="statement not covered" >i</span></span>f(u){let S=<span class="cstat-no" title="statement not covered" >u&amp;&amp;u.call(this);<span class="cstat-no" title="statement not covered" ></span>if(S)<span class="cstat-no" title="statement not covered" >return r.set.call(this,S),"function"==typeof T.removeAttribute&amp;&amp;T.removeAttribute(n),S}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>,he(e,n,r),e[c]=!0}</span>function <span class="fstat-no" title="function not covered" >Ye(</span>e,n,i){<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n.length;r++)<span class="cstat-no" title="statement not covered" >Xe(e,"on"+n[r],i);e</span></span>lse{const r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const c in e)<span class="cstat-no" title="statement not covered" >"on"==c.substr(0,2)&amp;&amp;r.push(c);<span class="cstat-no" title="statement not covered" >f</span></span>or(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;r.length;c++)<span class="cstat-no" title="statement not covered" >Xe(e,r[c],i)}</span></span>}</span>const ne=<span class="cstat-no" title="statement not covered" >x("originalInstance");</span>function <span class="fstat-no" title="function not covered" >ve(</span>e){const n=<span class="cstat-no" title="statement not covered" >$[e];<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >$</span></span>[x(e)]=n,$[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){const c=<span class="cstat-no" title="statement not covered" >Ae(arguments,e);<span class="cstat-no" title="statement not covered" ></span>switch(c.length){case 0:<span class="cstat-no" title="statement not covered" >this[ne]=new n;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 1:<span class="cstat-no" title="statement not covered" >this[ne]=new n(c[0]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 2:<span class="cstat-no" title="statement not covered" >this[ne]=new n(c[0],c[1]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 3:<span class="cstat-no" title="statement not covered" >this[ne]=new n(c[0],c[1],c[2]);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase 4:<span class="cstat-no" title="statement not covered" >this[ne]=new n(c[0],c[1],c[2],c[3]);<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >throw new Error("Arg list too long.")}</span>}</span>,ae($[e],n);c</span>onst i=<span class="cstat-no" title="statement not covered" >new n(<span class="fstat-no" title="function not covered" >fu</span>nction(){});</span>let r;<span class="cstat-no" title="statement not covered" >for(r in i)<span class="cstat-no" title="statement not covered" >"XMLHttpRequest"===e&amp;&amp;"responseBlob"===r||<span class="fstat-no" title="function not covered" >fu</span>nction(c){<span class="cstat-no" title="statement not covered" >"function"==typeof i[c]?$[e].prototype[c]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this[ne][c].apply(this[ne],arguments)}</span>:he($[e].prototype,c,{set:<span class="fstat-no" title="function not covered" >fu</span>nction(u){<span class="cstat-no" title="statement not covered" >"function"==typeof u?(this[ne][c]=Le(u,e+"."+c),ae(this[ne][c],u)):this[ne][c]=u}</span>,get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return this[ne][c]}</span>})}</span>(r);<span class="cstat-no" title="statement not covered" >f</span></span>or(r in n)<span class="cstat-no" title="statement not covered" >"prototype"!==r&amp;&amp;n.hasOwnProperty(r)&amp;&amp;($[e][r]=n[r])}</span></span>function <span class="fstat-no" title="function not covered" >ce(</span>e,n,i){let r=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(;r&amp;&amp;!r.hasOwnProperty(n);)<span class="cstat-no" title="statement not covered" >r=de(r);<span class="cstat-no" title="statement not covered" >!</span></span>r&amp;&amp;e[n]&amp;&amp;(r=e);c</span>onst c=<span class="cstat-no" title="statement not covered" >x(n);</span>let u=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;(!(u=r[c])||!r.hasOwnProperty(c))&amp;&amp;(u=r[c]=r[n],Fe(r&amp;&amp;ue(r,n)))){const _=<span class="cstat-no" title="statement not covered" >i(u,c,n);<span class="cstat-no" title="statement not covered" ></span>r[n]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return _(this,arguments)}</span>,ae(r[n],u)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn u}</span>function <span class="fstat-no" title="function not covered" >_t(</span>e,n,i){let r=<span class="cstat-no" title="statement not covered" >null;</span>function <span class="fstat-no" title="function not covered" >c(</span>u){const f=<span class="cstat-no" title="statement not covered" >u.data;<span class="cstat-no" title="statement not covered" ></span>return f.args[f.cbIdx]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >u.invoke.apply(this,arguments)}</span>,r.apply(f.target,f.args),u}<span class="cstat-no" title="statement not covered" ></span>r=ce(e,n,<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(f,_){const g=<span class="cstat-no" title="statement not covered" >i(f,_);<span class="cstat-no" title="statement not covered" ></span>return g.cbIdx&gt;=0&amp;&amp;"function"==typeof _[g.cbIdx]?Me(g.name,_[g.cbIdx],g,c):u.apply(f,_)}</span>)</span>}</span>function <span class="fstat-no" title="function not covered" >ae(</span>e,n){<span class="cstat-no" title="statement not covered" >e[x("OriginalDelegate")]=n}</span>let $e=<span class="cstat-no" title="statement not covered" >!1,</span>He=<span class="cstat-no" title="statement not covered" >!1;</span>function <span class="fstat-no" title="function not covered" >mt(</span>){<span class="cstat-no" title="statement not covered" >if($e)<span class="cstat-no" title="statement not covered" >return He;<span class="cstat-no" title="statement not covered" >$</span></span>e=!0;<span class="cstat-no" title="statement not covered" >t</span>ry{const e=<span class="cstat-no" title="statement not covered" >pe.navigator.userAgent;<span class="cstat-no" title="statement not covered" ></span>(-1!==e.indexOf("MSIE ")||-1!==e.indexOf("Trident/")||-1!==e.indexOf("Edge/"))&amp;&amp;(He=!0)}</span>catch(e){}<span class="cstat-no" title="statement not covered" >r</span>eturn He}<span class="cstat-no" title="statement not covered" ></span>Zone.__load_patch("ZoneAwarePromise",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{const r=<span class="cstat-no" title="statement not covered" >Object.getOwnPropertyDescriptor,</span>c=<span class="cstat-no" title="statement not covered" >Object.defineProperty,</span>f=<span class="cstat-no" title="statement not covered" >i.symbol,</span>_=<span class="cstat-no" title="statement not covered" >[],</span>g=<span class="cstat-no" title="statement not covered" >!0===e[f("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],</span>T=<span class="cstat-no" title="statement not covered" >f("Promise"),</span>m=<span class="cstat-no" title="statement not covered" >f("then");<span class="cstat-no" title="statement not covered" ></span>i.onUnhandledError=<span class="fstat-no" title="function not covered" >l=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(i.showUncaughtError()){const s=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.rejection;<span class="cstat-no" title="statement not covered" ></span>s?console.error("Unhandled Promise rejection:",s instanceof Error?s.message:s,"; Zone:",l.zone.name,"; Task:",l.task&amp;&amp;l.task.source,"; Value:",s,s instanceof Error?s.stack:void 0):console.error(l)}</span>}</span>,i.microtaskDrainDone=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >for(;_.length;){const l=<span class="cstat-no" title="statement not covered" >_.shift();<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >l.zone.runGuarded(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >throw l.throwOriginal?l.rejection:l}</span>)}</span>catch(s){<span class="cstat-no" title="statement not covered" >Z(s)}</span>}</span>}</span>;c</span>onst D=<span class="cstat-no" title="statement not covered" >f("unhandledPromiseRejectionHandler");</span>function <span class="fstat-no" title="function not covered" >Z(</span>l){<span class="cstat-no" title="statement not covered" >i.onUnhandledError(l);<span class="cstat-no" title="statement not covered" >t</span>ry{const s=<span class="cstat-no" title="statement not covered" >n[D];<span class="cstat-no" title="statement not covered" ></span>"function"==typeof s&amp;&amp;s.call(this,l)}</span>catch(s){}}</span>function <span class="fstat-no" title="function not covered" >B(</span>l){<span class="cstat-no" title="statement not covered" >return l&amp;&amp;l.then}</span>function <span class="fstat-no" title="function not covered" >V(</span>l){<span class="cstat-no" title="statement not covered" >return l}</span>function <span class="fstat-no" title="function not covered" >E(</span>l){<span class="cstat-no" title="statement not covered" >return t.reject(l)}</span>const d=<span class="cstat-no" title="statement not covered" >f("state"),</span>L=<span class="cstat-no" title="statement not covered" >f("value"),</span>z=<span class="cstat-no" title="statement not covered" >f("finally"),</span>j=<span class="cstat-no" title="statement not covered" >f("parentPromiseValue"),</span>q=<span class="cstat-no" title="statement not covered" >f("parentPromiseState"),</span>X=<span class="cstat-no" title="statement not covered" >null,</span>A=<span class="cstat-no" title="statement not covered" >!0,</span>Y=<span class="cstat-no" title="statement not covered" >!1;</span>function <span class="fstat-no" title="function not covered" >M(</span>l,s){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >a=</span>&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >G(l,s,a)}</span>catch(h){<span class="cstat-no" title="statement not covered" >G(l,!1,h)}</span>}</span>}</span>const le=<span class="cstat-no" title="statement not covered" >f("currentTaskTrace");</span>function <span class="fstat-no" title="function not covered" >G(</span>l,s,a){const h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){let l=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(a){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >l||(l=!0,a.apply(null,arguments))}</span>}</span>}</span>();<span class="cstat-no" title="statement not covered" ></span>if(l===a)<span class="cstat-no" title="statement not covered" >throw new TypeError("Promise resolved with itself");<span class="cstat-no" title="statement not covered" >i</span></span>f(l[d]===X){let w=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >("object"==typeof a||"function"==typeof a)&amp;&amp;(w=a&amp;&amp;a.then)}</span>catch(C){<span class="cstat-no" title="statement not covered" >return h(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >G(l,!1,C)}</span>)(),l}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s!==Y&amp;&amp;a instanceof t&amp;&amp;a.hasOwnProperty(d)&amp;&amp;a.hasOwnProperty(L)&amp;&amp;a[d]!==X)<span class="cstat-no" title="statement not covered" >re(a),G(l,a[d],a[L]);e</span>lse <span class="cstat-no" title="statement not covered" >if(s!==Y&amp;&amp;"function"==typeof w)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >w.call(a,h(M(l,s)),h(M(l,!1)))}</span>catch(C){<span class="cstat-no" title="statement not covered" >h(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >G(l,!1,C)}</span>)()}</span>e</span>lse{<span class="cstat-no" title="statement not covered" >l[d]=s;c</span>onst C=<span class="cstat-no" title="statement not covered" >l[L];<span class="cstat-no" title="statement not covered" ></span>if(l[L]=a,l[z]===z&amp;&amp;s===A&amp;&amp;(l[d]=l[q],l[L]=l[j]),s===Y&amp;&amp;a instanceof Error){const k=<span class="cstat-no" title="statement not covered" >n.currentTask&amp;&amp;n.currentTask.data&amp;&amp;n.currentTask.data.__creationTrace__;<span class="cstat-no" title="statement not covered" ></span>k&amp;&amp;c(a,le,{configurable:!0,enumerable:!1,writable:!0,value:k})}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let k=<span class="cstat-no" title="statement not covered" >0;</span>k&lt;C.length;)<span class="cstat-no" title="statement not covered" >F(l,C[k++],C[k++],C[k++],C[k++]);<span class="cstat-no" title="statement not covered" >i</span></span>f(0==C.length&amp;&amp;s==Y){<span class="cstat-no" title="statement not covered" >l[d]=0;l</span>et k=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >throw new Error("Uncaught (in promise): "+<span class="fstat-no" title="function not covered" >fu</span>nction(l){<span class="cstat-no" title="statement not covered" >return l&amp;&amp;l.toString===Object.prototype.toString?(l.constructor&amp;&amp;l.constructor.name||"")+": "+JSON.stringify(l):l?l.toString():Object.prototype.toString.call(l)}</span>(a)+(a&amp;&amp;a.stack?"\n"+a.stack:""))}</span>catch(b){<span class="cstat-no" title="statement not covered" >k=b}<span class="cstat-no" title="statement not covered" ></span>g</span>&amp;&amp;(k.throwOriginal=!0),k.rejection=a,k.promise=l,k.zone=n.current,k.task=n.currentTask,_.push(k),i.scheduleMicroTask()}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn l}</span>const te=<span class="cstat-no" title="statement not covered" >f("rejectionHandledHandler");</span>function <span class="fstat-no" title="function not covered" >re(</span>l){<span class="cstat-no" title="statement not covered" >if(0===l[d]){<span class="cstat-no" title="statement not covered" >try{const s=<span class="cstat-no" title="statement not covered" >n[te];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;"function"==typeof s&amp;&amp;s.call(this,{rejection:l[L],promise:l})}</span>catch(s){}<span class="cstat-no" title="statement not covered" >l</span>[d]=Y;<span class="cstat-no" title="statement not covered" >f</span>or(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;_.length;s++)<span class="cstat-no" title="statement not covered" >l===_[s].promise&amp;&amp;_.splice(s,1)}</span></span>}</span>function <span class="fstat-no" title="function not covered" >F(</span>l,s,a,h,w){<span class="cstat-no" title="statement not covered" >re(l);c</span>onst C=<span class="cstat-no" title="statement not covered" >l[d],</span>k=<span class="cstat-no" title="statement not covered" >C?"function"==typeof h?h:V:"function"==typeof w?w:E;<span class="cstat-no" title="statement not covered" ></span>s.scheduleMicroTask("Promise.then",<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >try{const b=<span class="cstat-no" title="statement not covered" >l[L],</span>N=<span class="cstat-no" title="statement not covered" >!!a&amp;&amp;z===a[z];<span class="cstat-no" title="statement not covered" ></span>N&amp;&amp;(a[j]=b,a[q]=C);c</span>onst H=<span class="cstat-no" title="statement not covered" >s.run(k,void 0,N&amp;&amp;k!==E&amp;&amp;k!==V?[]:[b]);<span class="cstat-no" title="statement not covered" ></span>G(a,!0,H)}</span>catch(b){<span class="cstat-no" title="statement not covered" >G(a,!1,b)}</span>}</span>,a)}</span>const p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){};</span>class t{<span class="fstat-no" title="function not covered" >st</span>atic toString(){<span class="cstat-no" title="statement not covered" >return"function ZoneAwarePromise() { [native code] }"}<span class="fstat-no" title="function not covered" ></span>st</span>atic resolve(s){<span class="cstat-no" title="statement not covered" >return G(new this(null),A,s)}<span class="fstat-no" title="function not covered" ></span>st</span>atic reject(s){<span class="cstat-no" title="statement not covered" >return G(new this(null),Y,s)}<span class="fstat-no" title="function not covered" ></span>st</span>atic race(s){let a,h,w=<span class="cstat-no" title="statement not covered" >new this(<span class="fstat-no" title="function not covered" >(b</span>,N)=&gt;{<span class="cstat-no" title="statement not covered" >a=b,h=N}</span>);</span>function <span class="fstat-no" title="function not covered" >C(</span>b){<span class="cstat-no" title="statement not covered" >a(b)}</span>function <span class="fstat-no" title="function not covered" >k(</span>b){<span class="cstat-no" title="statement not covered" >h(b)}<span class="cstat-no" title="statement not covered" ></span>for(let b of s)<span class="cstat-no" title="statement not covered" >B(b)||(b=this.resolve(b)),b.then(C,k);<span class="cstat-no" title="statement not covered" >r</span></span>eturn w}<span class="fstat-no" title="function not covered" ></span>st</span>atic all(s){<span class="cstat-no" title="statement not covered" >return t.allWithCallback(s)}<span class="fstat-no" title="function not covered" ></span>st</span>atic allSettled(s){<span class="cstat-no" title="statement not covered" >return(this&amp;&amp;this.prototype instanceof t?this:t).allWithCallback(s,{thenCallback:<span class="fstat-no" title="function not covered" >h=</span>&gt;(<span class="cstat-no" title="statement not covered" >{status:"fulfilled",value:h})</span>,errorCallback:<span class="fstat-no" title="function not covered" >h=</span>&gt;(<span class="cstat-no" title="statement not covered" >{status:"rejected",reason:h})</span>})}<span class="fstat-no" title="function not covered" ></span>st</span>atic allWithCallback(s,a){let h,w,C=<span class="cstat-no" title="statement not covered" >new this(<span class="fstat-no" title="function not covered" >(H</span>,U)=&gt;{<span class="cstat-no" title="statement not covered" >h=H,w=U}</span>),</span>k=<span class="cstat-no" title="statement not covered" >2,</span>b=<span class="cstat-no" title="statement not covered" >0;</span>const N=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let H of s){<span class="cstat-no" title="statement not covered" >B(H)||(H=this.resolve(H));c</span>onst U=<span class="cstat-no" title="statement not covered" >b;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >H.then(<span class="fstat-no" title="function not covered" >Q=</span>&gt;{<span class="cstat-no" title="statement not covered" >N[U]=a?a.thenCallback(Q):Q,k--,0===k&amp;&amp;h(N)}</span>,<span class="fstat-no" title="function not covered" >Q=</span>&gt;{<span class="cstat-no" title="statement not covered" >a?(N[U]=a.errorCallback(Q),k--,0===k&amp;&amp;h(N)):w(Q)}</span>)}</span>catch(Q){<span class="cstat-no" title="statement not covered" >w(Q)}<span class="cstat-no" title="statement not covered" ></span>k</span>++,b++}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn k-=2,0===k&amp;&amp;h(N),C}<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(s){const a=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!(a instanceof t))<span class="cstat-no" title="statement not covered" >throw new Error("Must be an instanceof Promise.");<span class="cstat-no" title="statement not covered" >a</span></span>[d]=X,a[L]=[];<span class="cstat-no" title="statement not covered" >t</span>ry{<span class="cstat-no" title="statement not covered" >s&amp;&amp;s(M(a,A),M(a,Y))}</span>catch(h){<span class="cstat-no" title="statement not covered" >G(a,!1,h)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.toStringTag](){<span class="cstat-no" title="statement not covered" >return"Promise"}<span class="fstat-no" title="function not covered" ></span>ge</span>t[Symbol.species](){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>th</span>en(s,a){let h=<span class="cstat-no" title="statement not covered" >this.constructor[Symbol.species];<span class="cstat-no" title="statement not covered" ></span>(!h||"function"!=typeof h)&amp;&amp;(h=this.constructor||t);c</span>onst w=<span class="cstat-no" title="statement not covered" >new h(p),</span>C=<span class="cstat-no" title="statement not covered" >n.current;<span class="cstat-no" title="statement not covered" ></span>return this[d]==X?this[L].push(C,w,s,a):F(this,C,w,s,a),w}<span class="fstat-no" title="function not covered" ></span>ca</span>tch(s){<span class="cstat-no" title="statement not covered" >return this.then(null,s)}<span class="fstat-no" title="function not covered" ></span>fi</span>nally(s){let a=<span class="cstat-no" title="statement not covered" >this.constructor[Symbol.species];<span class="cstat-no" title="statement not covered" ></span>(!a||"function"!=typeof a)&amp;&amp;(a=t);c</span>onst h=<span class="cstat-no" title="statement not covered" >new a(p);<span class="cstat-no" title="statement not covered" ></span>h[z]=z;c</span>onst w=<span class="cstat-no" title="statement not covered" >n.current;<span class="cstat-no" title="statement not covered" ></span>return this[d]==X?this[L].push(w,h,s,s):F(this,w,h,s,s),h}</span>}<span class="cstat-no" title="statement not covered" >t.resolve=t.resolve,t.reject=t.reject,t.race=t.race,t.all=t.all;c</span>onst o=<span class="cstat-no" title="statement not covered" >e[T]=e.Promise;<span class="cstat-no" title="statement not covered" ></span>e.Promise=t;c</span>onst y=<span class="cstat-no" title="statement not covered" >f("thenPatched");</span>function <span class="fstat-no" title="function not covered" >P(</span>l){const s=<span class="cstat-no" title="statement not covered" >l.prototype,</span>a=<span class="cstat-no" title="statement not covered" >r(s,"then");<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;(!1===a.writable||!a.configurable))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst h=<span class="cstat-no" title="statement not covered" >s.then;<span class="cstat-no" title="statement not covered" ></span>s[m]=h,l.prototype.then=<span class="fstat-no" title="function not covered" >fu</span>nction(w,C){<span class="cstat-no" title="statement not covered" >return new t(<span class="fstat-no" title="function not covered" >(b</span>,N)=&gt;{<span class="cstat-no" title="statement not covered" >h.call(this,b,N)}</span>).then(w,C)}</span>,l[y]=!0}<span class="cstat-no" title="statement not covered" ></span>return i.patchThen=P,o&amp;&amp;(P(o),ce(e,"fetch",<span class="fstat-no" title="function not covered" >l=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(l){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(s,a){let h=<span class="cstat-no" title="statement not covered" >l.apply(s,a);<span class="cstat-no" title="statement not covered" ></span>if(h instanceof t)<span class="cstat-no" title="statement not covered" >return h;l</span></span>et w=<span class="cstat-no" title="statement not covered" >h.constructor;<span class="cstat-no" title="statement not covered" ></span>return w[y]||P(w),h}</span>}</span>(l))</span>),Promise[n.__symbol__("uncaughtPromiseErrors")]=_,t}</span>),Zone.__load_patch("toString",<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >Function.prototype.toString,</span>i=<span class="cstat-no" title="statement not covered" >x("OriginalDelegate"),</span>r=<span class="cstat-no" title="statement not covered" >x("Promise"),</span>c=<span class="cstat-no" title="statement not covered" >x("Error"),</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if("function"==typeof this){const T=<span class="cstat-no" title="statement not covered" >this[i];<span class="cstat-no" title="statement not covered" ></span>if(T)<span class="cstat-no" title="statement not covered" >return"function"==typeof T?n.call(T):Object.prototype.toString.call(T);<span class="cstat-no" title="statement not covered" >i</span></span>f(this===Promise){const m=<span class="cstat-no" title="statement not covered" >e[r];<span class="cstat-no" title="statement not covered" ></span>if(m)<span class="cstat-no" title="statement not covered" >return n.call(m)}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(this===Error){const m=<span class="cstat-no" title="statement not covered" >e[c];<span class="cstat-no" title="statement not covered" ></span>if(m)<span class="cstat-no" title="statement not covered" >return n.call(m)}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n.call(this)}</span>;<span class="cstat-no" title="statement not covered" ></span>u[i]=n,Function.prototype.toString=u;c</span>onst f=<span class="cstat-no" title="statement not covered" >Object.prototype.toString;<span class="cstat-no" title="statement not covered" ></span>Object.prototype.toString=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"function"==typeof Promise&amp;&amp;this instanceof Promise?"[object Promise]":f.call(this)}</span>}</span>);l</span>et me=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if("undefined"!=typeof window)<span class="cstat-no" title="statement not covered" >try{const e=<span class="cstat-no" title="statement not covered" >Object.defineProperty({},"passive",{get:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >me=!0}</span>});<span class="cstat-no" title="statement not covered" ></span>window.addEventListener("test",e,e),window.removeEventListener("test",e,e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >me=!1}</span>c</span></span>onst Et=<span class="cstat-no" title="statement not covered" >{useG:!0},</span>ee=<span class="cstat-no" title="statement not covered" >{},</span>Ke=<span class="cstat-no" title="statement not covered" >{},</span>Je=<span class="cstat-no" title="statement not covered" >new RegExp("^"+ke+"(\\w+)(true|false)$"),</span>xe=<span class="cstat-no" title="statement not covered" >x("propagationStopped");</span>function <span class="fstat-no" title="function not covered" >Qe(</span>e,n){const i=<span class="cstat-no" title="statement not covered" >(n?n(e):e)+ie,</span>r=<span class="cstat-no" title="statement not covered" >(n?n(e):e)+se,</span>c=<span class="cstat-no" title="statement not covered" >ke+i,</span>u=<span class="cstat-no" title="statement not covered" >ke+r;<span class="cstat-no" title="statement not covered" ></span>ee[e]={},ee[e][ie]=c,ee[e][se]=u}</span>function <span class="fstat-no" title="function not covered" >Tt(</span>e,n,i){const r=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.add||Se,</span>c=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.rm||Oe,</span>u=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.listeners||"eventListeners",</span>f=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.rmAll||"removeAllListeners",</span>_=<span class="cstat-no" title="statement not covered" >x(r),</span>g=<span class="cstat-no" title="statement not covered" >"."+r+":",</span>S=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(E,d,L){<span class="cstat-no" title="statement not covered" >if(E.isRemoved)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst z=<span class="cstat-no" title="statement not covered" >E.callback;<span class="cstat-no" title="statement not covered" ></span>"object"==typeof z&amp;&amp;z.handleEvent&amp;&amp;(E.callback=<span class="fstat-no" title="function not covered" >q=</span>&gt;<span class="cstat-no" title="statement not covered" >z.handleEvent(q),</span>E.originalDelegate=z),E.invoke(E,d,[L]);c</span>onst j=<span class="cstat-no" title="statement not covered" >E.options;<span class="cstat-no" title="statement not covered" ></span>j&amp;&amp;"object"==typeof j&amp;&amp;j.once&amp;&amp;d[c].call(d,L.type,E.originalDelegate?E.originalDelegate:E.callback,j)}</span>,</span>D=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(E){<span class="cstat-no" title="statement not covered" >if(!(E=E||e.event))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst d=<span class="cstat-no" title="statement not covered" >this||E.target||e,</span>L=<span class="cstat-no" title="statement not covered" >d[ee[E.type][ie]];<span class="cstat-no" title="statement not covered" ></span>if(L)<span class="cstat-no" title="statement not covered" >if(1===L.length)<span class="cstat-no" title="statement not covered" >S(L[0],d,E);e</span>lse{const z=<span class="cstat-no" title="statement not covered" >L.slice();<span class="cstat-no" title="statement not covered" ></span>for(let j=<span class="cstat-no" title="statement not covered" >0;</span>j&lt;z.length&amp;&amp;(!E||!0!==E[xe]);j++)<span class="cstat-no" title="statement not covered" >S(z[j],d,E)}</span></span>}</span></span>,</span>Z=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(E){<span class="cstat-no" title="statement not covered" >if(!(E=E||e.event))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst d=<span class="cstat-no" title="statement not covered" >this||E.target||e,</span>L=<span class="cstat-no" title="statement not covered" >d[ee[E.type][se]];<span class="cstat-no" title="statement not covered" ></span>if(L)<span class="cstat-no" title="statement not covered" >if(1===L.length)<span class="cstat-no" title="statement not covered" >S(L[0],d,E);e</span>lse{const z=<span class="cstat-no" title="statement not covered" >L.slice();<span class="cstat-no" title="statement not covered" ></span>for(let j=<span class="cstat-no" title="statement not covered" >0;</span>j&lt;z.length&amp;&amp;(!E||!0!==E[xe]);j++)<span class="cstat-no" title="statement not covered" >S(z[j],d,E)}</span></span>}</span></span>;</span>function <span class="fstat-no" title="function not covered" >B(</span>E,d){<span class="cstat-no" title="statement not covered" >if(!E)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et L=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;void 0!==d.useG&amp;&amp;(L=d.useG);c</span>onst z=<span class="cstat-no" title="statement not covered" >d&amp;&amp;d.vh;</span>let j=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;void 0!==d.chkDup&amp;&amp;(j=d.chkDup);l</span>et q=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;void 0!==d.rt&amp;&amp;(q=d.rt);l</span>et O=<span class="cstat-no" title="statement not covered" >E;<span class="cstat-no" title="statement not covered" ></span>for(;O&amp;&amp;!O.hasOwnProperty(r);)<span class="cstat-no" title="statement not covered" >O=de(O);<span class="cstat-no" title="statement not covered" >i</span></span>f(!O&amp;&amp;E[r]&amp;&amp;(O=E),!O||O[_])<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst X=<span class="cstat-no" title="statement not covered" >d&amp;&amp;d.eventNameToString,</span>A=<span class="cstat-no" title="statement not covered" >{},</span>Y=<span class="cstat-no" title="statement not covered" >O[_]=O[r],</span>v=<span class="cstat-no" title="statement not covered" >O[x(c)]=O[c],</span>M=<span class="cstat-no" title="statement not covered" >O[x(u)]=O[u],</span>R=<span class="cstat-no" title="statement not covered" >O[x(f)]=O[f];</span>let J;function <span class="fstat-no" title="function not covered" >le(</span>s,a){<span class="cstat-no" title="statement not covered" >return!me&amp;&amp;"object"==typeof s&amp;&amp;s?!!s.capture:me&amp;&amp;a?"boolean"==typeof s?{capture:s,passive:!0}:s?"object"==typeof s&amp;&amp;!1!==s.passive?Object.assign(Object.assign({},s),{passive:!0}):s:{passive:!0}:s}<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;d.prepend&amp;&amp;(J=O[x(d.prepend)]=O[d.prepend]);c</span>onst p=<span class="cstat-no" title="statement not covered" >L?<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >if(!A.isExisting)<span class="cstat-no" title="statement not covered" >return Y.call(A.target,A.eventName,A.capture?Z:D,A.options)}</span></span>:<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >return Y.call(A.target,A.eventName,s.invoke,A.options)}</span>,</span>t=<span class="cstat-no" title="statement not covered" >L?<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >if(!s.isRemoved){const a=<span class="cstat-no" title="statement not covered" >ee[s.eventName];</span>let h;<span class="cstat-no" title="statement not covered" >a&amp;&amp;(h=a[s.capture?se:ie]);c</span>onst w=<span class="cstat-no" title="statement not covered" >h&amp;&amp;s.target[h];<span class="cstat-no" title="statement not covered" ></span>if(w)<span class="cstat-no" title="statement not covered" >for(let C=<span class="cstat-no" title="statement not covered" >0;</span>C&lt;w.length;C++)<span class="cstat-no" title="statement not covered" >if(w[C]===s){<span class="cstat-no" title="statement not covered" >w.splice(C,1),s.isRemoved=!0,0===w.length&amp;&amp;(s.allRemoved=!0,s.target[h]=null);<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span>i</span>f(s.allRemoved)<span class="cstat-no" title="statement not covered" >return v.call(s.target,s.eventName,s.capture?Z:D,s.options)}</span></span>:<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >return v.call(s.target,s.eventName,s.invoke,s.options)}</span>,</span>y=<span class="cstat-no" title="statement not covered" >d&amp;&amp;d.diff?d.diff:<span class="fstat-no" title="function not covered" >fu</span>nction(s,a){const h=<span class="cstat-no" title="statement not covered" >typeof a;<span class="cstat-no" title="statement not covered" ></span>return"function"===h&amp;&amp;s.callback===a||"object"===h&amp;&amp;s.originalDelegate===a}</span>,</span>P=<span class="cstat-no" title="statement not covered" >Zone[x("UNPATCHED_EVENTS")],</span>K=<span class="cstat-no" title="statement not covered" >e[x("PASSIVE_EVENTS")],</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(s,a,h,w,C=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>k=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(){const b=<span class="cstat-no" title="statement not covered" >this||e;</span>let N=<span class="cstat-no" title="statement not covered" >arguments[0];<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;d.transferEventName&amp;&amp;(N=d.transferEventName(N));l</span>et H=<span class="cstat-no" title="statement not covered" >arguments[1];<span class="cstat-no" title="statement not covered" ></span>if(!H)<span class="cstat-no" title="statement not covered" >return s.apply(this,arguments);<span class="cstat-no" title="statement not covered" >i</span></span>f(Re&amp;&amp;"uncaughtException"===N)<span class="cstat-no" title="statement not covered" >return s.apply(this,arguments);l</span></span>et U=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if("function"!=typeof H){<span class="cstat-no" title="statement not covered" >if(!H.handleEvent)<span class="cstat-no" title="statement not covered" >return s.apply(this,arguments);<span class="cstat-no" title="statement not covered" >U</span></span>=!0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(z&amp;&amp;!z(s,H,b,arguments))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst Q=<span class="cstat-no" title="statement not covered" >me&amp;&amp;!!K&amp;&amp;-1!==K.indexOf(N),</span>oe=<span class="cstat-no" title="statement not covered" >le(arguments[2],Q);<span class="cstat-no" title="statement not covered" ></span>if(P)<span class="cstat-no" title="statement not covered" >for(let _e=<span class="cstat-no" title="statement not covered" >0;</span>_e&lt;P.length;_e++)<span class="cstat-no" title="statement not covered" >if(N===P[_e])<span class="cstat-no" title="statement not covered" >return Q?s.call(b,N,H,oe):s.apply(this,arguments);c</span></span></span></span>onst Ge=<span class="cstat-no" title="statement not covered" >!!oe&amp;&amp;("boolean"==typeof oe||oe.capture),</span>st=<span class="cstat-no" title="statement not covered" >!(!oe||"object"!=typeof oe)&amp;&amp;oe.once,</span>At=<span class="cstat-no" title="statement not covered" >Zone.current;</span>let ze=<span class="cstat-no" title="statement not covered" >ee[N];<span class="cstat-no" title="statement not covered" ></span>ze||(Qe(N,X),ze=ee[N]);c</span>onst it=<span class="cstat-no" title="statement not covered" >ze[Ge?se:ie];</span>let De,ge=<span class="cstat-no" title="statement not covered" >b[it],</span>ct=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(ge){<span class="cstat-no" title="statement not covered" >if(ct=!0,j)<span class="cstat-no" title="statement not covered" >for(let _e=<span class="cstat-no" title="statement not covered" >0;</span>_e&lt;ge.length;_e++)<span class="cstat-no" title="statement not covered" >if(y(ge[_e],H))<span class="cstat-no" title="statement not covered" >return}</span></span></span></span>else <span class="cstat-no" title="statement not covered" >ge=b[it]=[];c</span></span>onst at=<span class="cstat-no" title="statement not covered" >b.constructor.name,</span>lt=<span class="cstat-no" title="statement not covered" >Ke[at];<span class="cstat-no" title="statement not covered" ></span>lt&amp;&amp;(De=lt[N]),De||(De=at+a+(X?X(N):N)),A.options=oe,st&amp;&amp;(A.options.once=!1),A.target=b,A.capture=Ge,A.eventName=N,A.isExisting=ct;c</span>onst be=<span class="cstat-no" title="statement not covered" >L?Et:void 0;<span class="cstat-no" title="statement not covered" ></span>be&amp;&amp;(be.taskData=A);c</span>onst fe=<span class="cstat-no" title="statement not covered" >At.scheduleEventTask(De,H,be,h,w);<span class="cstat-no" title="statement not covered" ></span>return A.target=null,be&amp;&amp;(be.taskData=null),st&amp;&amp;(oe.once=!0),!me&amp;&amp;"boolean"==typeof fe.options||(fe.options=oe),fe.target=b,fe.capture=Ge,fe.eventName=N,U&amp;&amp;(fe.originalDelegate=H),k?ge.unshift(fe):ge.push(fe),C?b:void 0}</span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return O[r]=l(Y,g,p,t,q),J&amp;&amp;(O.prependListener=l(J,".prependListener:",<span class="fstat-no" title="function not covered" >fu</span>nction(s){<span class="cstat-no" title="statement not covered" >return J.call(A.target,A.eventName,s.invoke,A.options)}</span>,t,q,!0)),O[c]=<span class="fstat-no" title="function not covered" >fu</span>nction(){const s=<span class="cstat-no" title="statement not covered" >this||e;</span>let a=<span class="cstat-no" title="statement not covered" >arguments[0];<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;d.transferEventName&amp;&amp;(a=d.transferEventName(a));c</span>onst h=<span class="cstat-no" title="statement not covered" >arguments[2],</span>w=<span class="cstat-no" title="statement not covered" >!!h&amp;&amp;("boolean"==typeof h||h.capture),</span>C=<span class="cstat-no" title="statement not covered" >arguments[1];<span class="cstat-no" title="statement not covered" ></span>if(!C)<span class="cstat-no" title="statement not covered" >return v.apply(this,arguments);<span class="cstat-no" title="statement not covered" >i</span></span>f(z&amp;&amp;!z(v,C,s,arguments))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst k=<span class="cstat-no" title="statement not covered" >ee[a];</span>let b;<span class="cstat-no" title="statement not covered" >k&amp;&amp;(b=k[w?se:ie]);c</span>onst N=<span class="cstat-no" title="statement not covered" >b&amp;&amp;s[b];<span class="cstat-no" title="statement not covered" ></span>if(N)<span class="cstat-no" title="statement not covered" >for(let H=<span class="cstat-no" title="statement not covered" >0;</span>H&lt;N.length;H++){const U=<span class="cstat-no" title="statement not covered" >N[H];<span class="cstat-no" title="statement not covered" ></span>if(y(U,C))<span class="cstat-no" title="statement not covered" >return N.splice(H,1),U.isRemoved=!0,0===N.length&amp;&amp;(U.allRemoved=!0,s[b]=null,"string"==typeof a)&amp;&amp;(s[ke+"ON_PROPERTY"+a]=null),U.zone.cancelTask(U),q?s:void 0}<span class="cstat-no" title="statement not covered" ></span></span>r</span></span>eturn v.apply(this,arguments)}</span>,O[u]=<span class="fstat-no" title="function not covered" >fu</span>nction(){const s=<span class="cstat-no" title="statement not covered" >this||e;</span>let a=<span class="cstat-no" title="statement not covered" >arguments[0];<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;d.transferEventName&amp;&amp;(a=d.transferEventName(a));c</span>onst h=<span class="cstat-no" title="statement not covered" >[],</span>w=<span class="cstat-no" title="statement not covered" >et(s,X?X(a):a);<span class="cstat-no" title="statement not covered" ></span>for(let C=<span class="cstat-no" title="statement not covered" >0;</span>C&lt;w.length;C++){const k=<span class="cstat-no" title="statement not covered" >w[C];<span class="cstat-no" title="statement not covered" ></span>h.push(k.originalDelegate?k.originalDelegate:k.callback)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn h}</span>,O[f]=<span class="fstat-no" title="function not covered" >fu</span>nction(){const s=<span class="cstat-no" title="statement not covered" >this||e;</span>let a=<span class="cstat-no" title="statement not covered" >arguments[0];<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >d&amp;&amp;d.transferEventName&amp;&amp;(a=d.transferEventName(a));c</span>onst h=<span class="cstat-no" title="statement not covered" >ee[a];<span class="cstat-no" title="statement not covered" ></span>if(h){const k=<span class="cstat-no" title="statement not covered" >s[h[ie]],</span>b=<span class="cstat-no" title="statement not covered" >s[h[se]];<span class="cstat-no" title="statement not covered" ></span>if(k){const N=<span class="cstat-no" title="statement not covered" >k.slice();<span class="cstat-no" title="statement not covered" ></span>for(let H=<span class="cstat-no" title="statement not covered" >0;</span>H&lt;N.length;H++){const U=<span class="cstat-no" title="statement not covered" >N[H];<span class="cstat-no" title="statement not covered" ></span>this[c].call(this,a,U.originalDelegate?U.originalDelegate:U.callback,U.options)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(b){const N=<span class="cstat-no" title="statement not covered" >b.slice();<span class="cstat-no" title="statement not covered" ></span>for(let H=<span class="cstat-no" title="statement not covered" >0;</span>H&lt;N.length;H++){const U=<span class="cstat-no" title="statement not covered" >N[H];<span class="cstat-no" title="statement not covered" ></span>this[c].call(this,a,U.originalDelegate?U.originalDelegate:U.callback,U.options)}</span>}</span>}</span>}</span>else{const h=<span class="cstat-no" title="statement not covered" >Object.keys(s);<span class="cstat-no" title="statement not covered" ></span>for(let w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;h.length;w++){const k=<span class="cstat-no" title="statement not covered" >Je.exec(h[w]);</span>let b=<span class="cstat-no" title="statement not covered" >k&amp;&amp;k[1];<span class="cstat-no" title="statement not covered" ></span>b&amp;&amp;"removeListener"!==b&amp;&amp;this[f].call(this,b)}<span class="cstat-no" title="statement not covered" ></span>t</span>his[f].call(this,"removeListener")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(q)<span class="cstat-no" title="statement not covered" >return this}</span></span>,ae(O[r],Y),ae(O[c],v),R&amp;&amp;ae(O[f],R),M&amp;&amp;ae(O[u],M),!0}</span>let V=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let E=<span class="cstat-no" title="statement not covered" >0;</span>E&lt;n.length;E++)<span class="cstat-no" title="statement not covered" >V[E]=B(n[E],i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn V}</span>function <span class="fstat-no" title="function not covered" >et(</span>e,n){<span class="cstat-no" title="statement not covered" >if(!n){const u=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let f in e){const _=<span class="cstat-no" title="statement not covered" >Je.exec(f);</span>let g=<span class="cstat-no" title="statement not covered" >_&amp;&amp;_[1];<span class="cstat-no" title="statement not covered" ></span>if(g&amp;&amp;(!n||g===n)){const T=<span class="cstat-no" title="statement not covered" >e[f];<span class="cstat-no" title="statement not covered" ></span>if(T)<span class="cstat-no" title="statement not covered" >for(let m=<span class="cstat-no" title="statement not covered" >0;</span>m&lt;T.length;m++)<span class="cstat-no" title="statement not covered" >u.push(T[m])}</span></span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn u}</span>l</span>et i=<span class="cstat-no" title="statement not covered" >ee[n];<span class="cstat-no" title="statement not covered" ></span>i||(Qe(n),i=ee[n]);c</span>onst r=<span class="cstat-no" title="statement not covered" >e[i[ie]],</span>c=<span class="cstat-no" title="statement not covered" >e[i[se]];<span class="cstat-no" title="statement not covered" ></span>return r?c?r.concat(c):r.slice():c?c.slice():[]}</span>function <span class="fstat-no" title="function not covered" >yt(</span>e,n){const i=<span class="cstat-no" title="statement not covered" >e.Event;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.prototype&amp;&amp;n.patchMethod(i.prototype,"stopImmediatePropagation",<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(c,u){<span class="cstat-no" title="statement not covered" >c[xe]=!0,r&amp;&amp;r.apply(c,u)}</span>)</span>}</span>function <span class="fstat-no" title="function not covered" >gt(</span>e,n,i,r,c){const u=<span class="cstat-no" title="statement not covered" >Zone.__symbol__(r);<span class="cstat-no" title="statement not covered" ></span>if(n[u])<span class="cstat-no" title="statement not covered" >return;c</span></span>onst f=<span class="cstat-no" title="statement not covered" >n[u]=n[r];<span class="cstat-no" title="statement not covered" ></span>n[r]=<span class="fstat-no" title="function not covered" >fu</span>nction(_,g,T){<span class="cstat-no" title="statement not covered" >return g&amp;&amp;g.prototype&amp;&amp;c.forEach(<span class="fstat-no" title="function not covered" >fu</span>nction(m){const S=<span class="cstat-no" title="statement not covered" >`${i}.${r}::`+m,</span>D=<span class="cstat-no" title="statement not covered" >g.prototype;<span class="cstat-no" title="statement not covered" ></span>if(D.hasOwnProperty(m)){const Z=<span class="cstat-no" title="statement not covered" >e.ObjectGetOwnPropertyDescriptor(D,m);<span class="cstat-no" title="statement not covered" ></span>Z&amp;&amp;Z.value?(Z.value=e.wrapWithCurrentZone(Z.value,S),e._redefineProperty(g.prototype,m,Z)):D[m]&amp;&amp;(D[m]=e.wrapWithCurrentZone(D[m],S))}</span>else <span class="cstat-no" title="statement not covered" >D[m]&amp;&amp;(D[m]=e.wrapWithCurrentZone(D[m],S))}</span></span>),f.call(n,_,g,T)}</span>,e.attachOriginToPatched(n[r],f)}</span>const Ve=<span class="cstat-no" title="statement not covered" >["absolutedeviceorientation","afterinput","afterprint","appinstalled","beforeinstallprompt","beforeprint","beforeunload","devicelight","devicemotion","deviceorientation","deviceorientationabsolute","deviceproximity","hashchange","languagechange","message","mozbeforepaint","offline","online","paint","pageshow","pagehide","popstate","rejectionhandled","storage","unhandledrejection","unload","userproximity","vrdisplayconnected","vrdisplaydisconnected","vrdisplaypresentchange"],</span>wt=<span class="cstat-no" title="statement not covered" >["encrypted","waitingforkey","msneedkey","mozinterruptbegin","mozinterruptend"],</span>tt=<span class="cstat-no" title="statement not covered" >["load"],</span>nt=<span class="cstat-no" title="statement not covered" >["blur","error","focus","load","resize","scroll","messageerror"],</span>Dt=<span class="cstat-no" title="statement not covered" >["bounce","finish","start"],</span>rt=<span class="cstat-no" title="statement not covered" >["loadstart","progress","abort","error","load","progress","timeout","loadend","readystatechange"],</span>Ee=<span class="cstat-no" title="statement not covered" >["upgradeneeded","complete","abort","success","error","blocked","versionchange","close"],</span>St=<span class="cstat-no" title="statement not covered" >["close","error","open","message"],</span>Ot=<span class="cstat-no" title="statement not covered" >["error","message"],</span>Te=<span class="cstat-no" title="statement not covered" >["abort","animationcancel","animationend","animationiteration","auxclick","beforeinput","blur","cancel","canplay","canplaythrough","change","compositionstart","compositionupdate","compositionend","cuechange","click","close","contextmenu","curechange","dblclick","drag","dragend","dragenter","dragexit","dragleave","dragover","drop","durationchange","emptied","ended","error","focus","focusin","focusout","gotpointercapture","input","invalid","keydown","keypress","keyup","load","loadstart","loadeddata","loadedmetadata","lostpointercapture","mousedown","mouseenter","mouseleave","mousemove","mouseout","mouseover","mouseup","mousewheel","orientationchange","pause","play","playing","pointercancel","pointerdown","pointerenter","pointerleave","pointerlockchange","mozpointerlockchange","webkitpointerlockerchange","pointerlockerror","mozpointerlockerror","webkitpointerlockerror","pointermove","pointout","pointerover","pointerup","progress","ratechange","reset","resize","scroll","seeked","seeking","select","selectionchange","selectstart","show","sort","stalled","submit","suspend","timeupdate","volumechange","touchcancel","touchmove","touchstart","touchend","transitioncancel","transitionend","waiting","wheel"].concat(["webglcontextrestored","webglcontextlost","webglcontextcreationerror"],["autocomplete","autocompleteerror"],["toggle"],["afterscriptexecute","beforescriptexecute","DOMContentLoaded","freeze","fullscreenchange","mozfullscreenchange","webkitfullscreenchange","msfullscreenchange","fullscreenerror","mozfullscreenerror","webkitfullscreenerror","msfullscreenerror","readystatechange","visibilitychange","resume"],Ve,["beforecopy","beforecut","beforepaste","copy","cut","paste","dragstart","loadend","animationstart","search","transitionrun","transitionstart","webkitanimationend","webkitanimationiteration","webkitanimationstart","webkittransitionend"],["activate","afterupdate","ariarequest","beforeactivate","beforedeactivate","beforeeditfocus","beforeupdate","cellchange","controlselect","dataavailable","datasetchanged","datasetcomplete","errorupdate","filterchange","layoutcomplete","losecapture","move","moveend","movestart","propertychange","resizeend","resizestart","rowenter","rowexit","rowsdelete","rowsinserted","command","compassneedscalibration","deactivate","help","mscontentzoom","msmanipulationstatechanged","msgesturechange","msgesturedoubletap","msgestureend","msgesturehold","msgesturestart","msgesturetap","msgotpointercapture","msinertiastart","mslostpointercapture","mspointercancel","mspointerdown","mspointerenter","mspointerhover","mspointerleave","mspointermove","mspointerout","mspointerover","mspointerup","pointerout","mssitemodejumplistitemremoved","msthumbnailclick","stop","storagecommit"]);</span>function <span class="fstat-no" title="function not covered" >ot(</span>e,n,i){<span class="cstat-no" title="statement not covered" >if(!i||0===i.length)<span class="cstat-no" title="statement not covered" >return n;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >i.filter(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >u.target===e)</span>;<span class="cstat-no" title="statement not covered" ></span>if(!r||0===r.length)<span class="cstat-no" title="statement not covered" >return n;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >r[0].ignoreProperties;<span class="cstat-no" title="statement not covered" ></span>return n.filter(<span class="fstat-no" title="function not covered" >u=</span>&gt;<span class="cstat-no" title="statement not covered" >-1===c.indexOf(u))</span>}</span>function <span class="fstat-no" title="function not covered" >W(</span>e,n,i,r){<span class="cstat-no" title="statement not covered" >e&amp;&amp;Ye(e,ot(e,n,i),r)}<span class="cstat-no" title="statement not covered" ></span>Zone.__load_patch("util",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{<span class="cstat-no" title="statement not covered" >i.patchOnProperties=Ye,i.patchMethod=ce,i.bindArguments=Ae,i.patchMacroTask=_t;c</span>onst r=<span class="cstat-no" title="statement not covered" >n.__symbol__("BLACK_LISTED_EVENTS"),</span>c=<span class="cstat-no" title="statement not covered" >n.__symbol__("UNPATCHED_EVENTS");<span class="cstat-no" title="statement not covered" ></span>e[c]&amp;&amp;(e[r]=e[c]),e[r]&amp;&amp;(n[r]=n[c]=e[r]),i.patchEventPrototype=yt,i.patchEventTarget=Tt,i.isIEOrEdge=mt,i.ObjectDefineProperty=he,i.ObjectGetOwnPropertyDescriptor=ue,i.ObjectCreate=Be,i.ArraySlice=ut,i.patchClass=ve,i.wrapWithCurrentZone=Le,i.filterProperties=ot,i.attachOriginToPatched=ae,i._redefineProperty=Object.defineProperty,i.patchCallbacks=gt,i.getGlobalObjects=<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{globalSources:Ke,zoneSymbolEventNames:ee,eventNames:Te,isBrowser:je,isMix:We,isNode:Re,TRUE_STR:se,FALSE_STR:ie,ZONE_SYMBOL_PREFIX:ke,ADD_EVENT_LISTENER_STR:Se,REMOVE_EVENT_LISTENER_STR:Oe})</span>}</span>);c</span>onst Ne=<span class="cstat-no" title="statement not covered" >x("zoneTask");</span>function <span class="fstat-no" title="function not covered" >ye(</span>e,n,i,r){let c=<span class="cstat-no" title="statement not covered" >null,</span>u=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>i+=r;c</span>onst f=<span class="cstat-no" title="statement not covered" >{};</span>function <span class="fstat-no" title="function not covered" >_(</span>T){const m=<span class="cstat-no" title="statement not covered" >T.data;<span class="cstat-no" title="statement not covered" ></span>return m.args[0]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return T.invoke.apply(this,arguments)}</span>,m.handleId=c.apply(e,m.args),T}</span>function <span class="fstat-no" title="function not covered" >g(</span>T){<span class="cstat-no" title="statement not covered" >return u.call(e,T.data.handleId)}<span class="cstat-no" title="statement not covered" ></span>c=ce(e,n+=r,<span class="fstat-no" title="function not covered" >T=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(m,S){<span class="cstat-no" title="statement not covered" >if("function"==typeof S[0]){const D=<span class="cstat-no" title="statement not covered" >{isPeriodic:"Interval"===r,delay:"Timeout"===r||"Interval"===r?S[1]||0:void 0,args:S},</span>Z=<span class="cstat-no" title="statement not covered" >S[0];<span class="cstat-no" title="statement not covered" ></span>S[0]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return Z.apply(this,arguments)}</span>finally{<span class="cstat-no" title="statement not covered" >D.isPeriodic||("number"==typeof D.handleId?delete f[D.handleId]:D.handleId&amp;&amp;(D.handleId[Ne]=null))}</span>}</span>;c</span>onst B=<span class="cstat-no" title="statement not covered" >Me(n,S[0],D,_,g);<span class="cstat-no" title="statement not covered" ></span>if(!B)<span class="cstat-no" title="statement not covered" >return B;c</span></span>onst V=<span class="cstat-no" title="statement not covered" >B.data.handleId;<span class="cstat-no" title="statement not covered" ></span>return"number"==typeof V?f[V]=B:V&amp;&amp;(V[Ne]=B),V&amp;&amp;V.ref&amp;&amp;V.unref&amp;&amp;"function"==typeof V.ref&amp;&amp;"function"==typeof V.unref&amp;&amp;(B.ref=V.ref.bind(V),B.unref=V.unref.bind(V)),"number"==typeof V||V?V:B}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn T.apply(e,S)}</span>)</span>,u=ce(e,i,<span class="fstat-no" title="function not covered" >T=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(m,S){const D=<span class="cstat-no" title="statement not covered" >S[0];</span>let Z;<span class="cstat-no" title="statement not covered" >"number"==typeof D?Z=f[D]:(Z=D&amp;&amp;D[Ne],Z||(Z=D)),Z&amp;&amp;"string"==typeof Z.type?"notScheduled"!==Z.state&amp;&amp;(Z.cancelFn&amp;&amp;Z.data.isPeriodic||0===Z.runCount)&amp;&amp;("number"==typeof D?delete f[D]:D&amp;&amp;(D[Ne]=null),Z.zone.cancelTask(Z)):T.apply(e,S)}</span>)</span>}<span class="cstat-no" title="statement not covered" ></span>Zone.__load_patch("legacy",<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >e[Zone.__symbol__("legacyPatch")];<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n()}</span>),Zone.__load_patch("queueMicrotask",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{<span class="cstat-no" title="statement not covered" >i.patchMethod(e,"queueMicrotask",<span class="fstat-no" title="function not covered" >r=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(c,u){<span class="cstat-no" title="statement not covered" >n.current.scheduleMicroTask("queueMicrotask",u[0])}</span>)</span>}</span>),Zone.__load_patch("timers",<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >"set",</span>i=<span class="cstat-no" title="statement not covered" >"clear";<span class="cstat-no" title="statement not covered" ></span>ye(e,n,i,"Timeout"),ye(e,n,i,"Interval"),ye(e,n,i,"Immediate")}</span>),Zone.__load_patch("requestAnimationFrame",<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >ye(e,"request","cancel","AnimationFrame"),ye(e,"mozRequest","mozCancel","AnimationFrame"),ye(e,"webkitRequest","webkitCancel","AnimationFrame")}</span>),Zone.__load_patch("blocking",<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{const i=<span class="cstat-no" title="statement not covered" >["alert","prompt","confirm"];<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;i.length;r++)<span class="cstat-no" title="statement not covered" >ce(e,i[r],<span class="fstat-no" title="function not covered" >(u</span>,f,_)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(g,T){<span class="cstat-no" title="statement not covered" >return n.current.run(u,e,T,_)}</span>)</span>}</span></span>),Zone.__load_patch("EventTarget",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >n.patchEventPrototype(e,n)}</span>)(e,i),<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(Zone[n.symbol("patchEventTarget")])<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{eventNames:i,zoneSymbolEventNames:r,TRUE_STR:c,FALSE_STR:u,ZONE_SYMBOL_PREFIX:f}=<span class="cstat-no" title="statement not covered" >n.getGlobalObjects();<span class="cstat-no" title="statement not covered" ></span>for(let g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;i.length;g++){const T=<span class="cstat-no" title="statement not covered" >i[g],</span>D=<span class="cstat-no" title="statement not covered" >f+(T+u),</span>Z=<span class="cstat-no" title="statement not covered" >f+(T+c);<span class="cstat-no" title="statement not covered" ></span>r[T]={},r[T][u]=D,r[T][c]=Z}</span>c</span>onst _=<span class="cstat-no" title="statement not covered" >e.EventTarget;<span class="cstat-no" title="statement not covered" ></span>_&amp;&amp;_.prototype&amp;&amp;n.patchEventTarget(e,[_&amp;&amp;_.prototype])}</span>(e,i);c</span>onst r=<span class="cstat-no" title="statement not covered" >e.XMLHttpRequestEventTarget;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;r.prototype&amp;&amp;i.patchEventTarget(e,[r.prototype])}</span>),Zone.__load_patch("MutationObserver",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{<span class="cstat-no" title="statement not covered" >ve("MutationObserver"),ve("WebKitMutationObserver")}</span>),Zone.__load_patch("IntersectionObserver",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{<span class="cstat-no" title="statement not covered" >ve("IntersectionObserver")}</span>),Zone.__load_patch("FileReader",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{<span class="cstat-no" title="statement not covered" >ve("FileReader")}</span>),Zone.__load_patch("on_property",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >if(Re&amp;&amp;!We||Zone[e.symbol("patchEvents")])<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >"undefined"!=typeof WebSocket,</span>r=<span class="cstat-no" title="statement not covered" >n.__Zone_ignore_on_properties;<span class="cstat-no" title="statement not covered" ></span>if(je){const f=<span class="cstat-no" title="statement not covered" >window,</span>_=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >try{const e=<span class="cstat-no" title="statement not covered" >pe.navigator.userAgent;<span class="cstat-no" title="statement not covered" ></span>if(-1!==e.indexOf("MSIE ")||-1!==e.indexOf("Trident/"))<span class="cstat-no" title="statement not covered" >return!0}</span></span>catch(e){}<span class="cstat-no" title="statement not covered" >r</span>eturn!1}</span>()?[{target:f,ignoreProperties:["error"]}]:[];<span class="cstat-no" title="statement not covered" ></span>W(f,Te.concat(["messageerror"]),r&amp;&amp;r.concat(_),de(f)),W(Document.prototype,Te,r),void 0!==f.SVGElement&amp;&amp;W(f.SVGElement.prototype,Te,r),W(Element.prototype,Te,r),W(HTMLElement.prototype,Te,r),W(HTMLMediaElement.prototype,wt,r),W(HTMLFrameSetElement.prototype,Ve.concat(nt),r),W(HTMLBodyElement.prototype,Ve.concat(nt),r),W(HTMLFrameElement.prototype,tt,r),W(HTMLIFrameElement.prototype,tt,r);c</span>onst g=<span class="cstat-no" title="statement not covered" >f.HTMLMarqueeElement;<span class="cstat-no" title="statement not covered" ></span>g&amp;&amp;W(g.prototype,Dt,r);c</span>onst T=<span class="cstat-no" title="statement not covered" >f.Worker;<span class="cstat-no" title="statement not covered" ></span>T&amp;&amp;W(T.prototype,Ot,r)}</span>c</span>onst c=<span class="cstat-no" title="statement not covered" >n.XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;W(c.prototype,rt,r);c</span>onst u=<span class="cstat-no" title="statement not covered" >n.XMLHttpRequestEventTarget;<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;W(u&amp;&amp;u.prototype,rt,r),"undefined"!=typeof IDBIndex&amp;&amp;(W(IDBIndex.prototype,Ee,r),W(IDBRequest.prototype,Ee,r),W(IDBOpenDBRequest.prototype,Ee,r),W(IDBDatabase.prototype,Ee,r),W(IDBTransaction.prototype,Ee,r),W(IDBCursor.prototype,Ee,r)),i&amp;&amp;W(WebSocket.prototype,St,r)}</span>(i,e)}</span>),Zone.__load_patch("customElements",<span class="fstat-no" title="function not covered" >(e</span>,n,i)=&gt;{<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){const{isBrowser:i,isMix:r}=<span class="cstat-no" title="statement not covered" >n.getGlobalObjects();<span class="cstat-no" title="statement not covered" ></span>(i||r)&amp;&amp;e.customElements&amp;&amp;"customElements"in e&amp;&amp;n.patchCallbacks(n,e.customElements,"customElements","define",["connectedCallback","disconnectedCallback","adoptedCallback","attributeChangedCallback"])}</span>(e,i)}</span>),Zone.__load_patch("XHR",<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(T){const m=<span class="cstat-no" title="statement not covered" >T.XMLHttpRequest;<span class="cstat-no" title="statement not covered" ></span>if(!m)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst S=<span class="cstat-no" title="statement not covered" >m.prototype;</span>let Z=<span class="cstat-no" title="statement not covered" >S[Ze],</span>B=<span class="cstat-no" title="statement not covered" >S[Ie];<span class="cstat-no" title="statement not covered" ></span>if(!Z){const v=<span class="cstat-no" title="statement not covered" >T.XMLHttpRequestEventTarget;<span class="cstat-no" title="statement not covered" ></span>if(v){const M=<span class="cstat-no" title="statement not covered" >v.prototype;<span class="cstat-no" title="statement not covered" ></span>Z=M[Ze],B=M[Ie]}</span>}</span>c</span>onst V=<span class="cstat-no" title="statement not covered" >"readystatechange",</span>E=<span class="cstat-no" title="statement not covered" >"scheduled";</span>function <span class="fstat-no" title="function not covered" >d(</span>v){const M=<span class="cstat-no" title="statement not covered" >v.data,</span>R=<span class="cstat-no" title="statement not covered" >M.target;<span class="cstat-no" title="statement not covered" ></span>R[u]=!1,R[_]=!1;c</span>onst J=<span class="cstat-no" title="statement not covered" >R[c];<span class="cstat-no" title="statement not covered" ></span>Z||(Z=R[Ze],B=R[Ie]),J&amp;&amp;B.call(R,V,J);c</span>onst le=<span class="cstat-no" title="statement not covered" >R[c]=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(R.readyState===R.DONE)<span class="cstat-no" title="statement not covered" >if(!M.aborted&amp;&amp;R[u]&amp;&amp;v.state===E){const te=<span class="cstat-no" title="statement not covered" >R[n.__symbol__("loadfalse")];<span class="cstat-no" title="statement not covered" ></span>if(0!==R.status&amp;&amp;te&amp;&amp;te.length&gt;0){const re=<span class="cstat-no" title="statement not covered" >v.invoke;<span class="cstat-no" title="statement not covered" ></span>v.invoke=<span class="fstat-no" title="function not covered" >fu</span>nction(){const F=<span class="cstat-no" title="statement not covered" >R[n.__symbol__("loadfalse")];<span class="cstat-no" title="statement not covered" ></span>for(let I=<span class="cstat-no" title="statement not covered" >0;</span>I&lt;F.length;I++)<span class="cstat-no" title="statement not covered" >F[I]===v&amp;&amp;F.splice(I,1);<span class="cstat-no" title="statement not covered" >!</span></span>M.aborted&amp;&amp;v.state===E&amp;&amp;re.call(v)}</span>,te.push(v)}</span>else <span class="cstat-no" title="statement not covered" >v.invoke()}</span></span>else<span class="cstat-no" title="statement not covered" >!M.aborted&amp;&amp;!1===R[u]&amp;&amp;(R[_]=!0)}</span></span></span>;<span class="cstat-no" title="statement not covered" ></span>return Z.call(R,V,le),R[i]||(R[i]=v),A.apply(R,M.args),R[u]=!0,v}</span>function <span class="fstat-no" title="function not covered" >L(</span>){}function <span class="fstat-no" title="function not covered" >z(</span>v){const M=<span class="cstat-no" title="statement not covered" >v.data;<span class="cstat-no" title="statement not covered" ></span>return M.aborted=!0,Y.apply(M.target,M.args)}</span>const j=<span class="cstat-no" title="statement not covered" >ce(S,"open",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(v,M){<span class="cstat-no" title="statement not covered" >return v[r]=0==M[2],v[f]=M[1],j.apply(v,M)}</span>)</span>,</span>O=<span class="cstat-no" title="statement not covered" >x("fetchTaskAborting"),</span>X=<span class="cstat-no" title="statement not covered" >x("fetchTaskScheduling"),</span>A=<span class="cstat-no" title="statement not covered" >ce(S,"send",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(v,M){<span class="cstat-no" title="statement not covered" >if(!0===n.current[X]||v[r])<span class="cstat-no" title="statement not covered" >return A.apply(v,M);{</span></span>const R=<span class="cstat-no" title="statement not covered" >{target:v,url:v[f],isPeriodic:!1,args:M,aborted:!1},</span>J=<span class="cstat-no" title="statement not covered" >Me("XMLHttpRequest.send",L,R,d,z);<span class="cstat-no" title="statement not covered" ></span>v&amp;&amp;!0===v[_]&amp;&amp;!R.aborted&amp;&amp;J.state===E&amp;&amp;J.invoke()}</span>})</span>,</span>Y=<span class="cstat-no" title="statement not covered" >ce(S,"abort",<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(v,M){const R=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(v){<span class="cstat-no" title="statement not covered" >return v[i]}</span>(v);<span class="cstat-no" title="statement not covered" ></span>if(R&amp;&amp;"string"==typeof R.type){<span class="cstat-no" title="statement not covered" >if(null==R.cancelFn||R.data&amp;&amp;R.data.aborted)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >R</span></span>.zone.cancelTask(R)}</span>else <span class="cstat-no" title="statement not covered" >if(!0===n.current[O])<span class="cstat-no" title="statement not covered" >return Y.apply(v,M)}</span></span></span>)</span>}</span>(e);c</span>onst i=<span class="cstat-no" title="statement not covered" >x("xhrTask"),</span>r=<span class="cstat-no" title="statement not covered" >x("xhrSync"),</span>c=<span class="cstat-no" title="statement not covered" >x("xhrListener"),</span>u=<span class="cstat-no" title="statement not covered" >x("xhrScheduled"),</span>f=<span class="cstat-no" title="statement not covered" >x("xhrURL"),</span>_=<span class="cstat-no" title="statement not covered" >x("xhrErrorBeforeScheduled")}</span>),Zone.__load_patch("geolocation",<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.navigator&amp;&amp;e.navigator.geolocation&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){const i=<span class="cstat-no" title="statement not covered" >e.constructor.name;<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;n.length;r++){const c=<span class="cstat-no" title="statement not covered" >n[r],</span>u=<span class="cstat-no" title="statement not covered" >e[c];<span class="cstat-no" title="statement not covered" ></span>if(u){<span class="cstat-no" title="statement not covered" >if(!Fe(ue(e,c)))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >e</span></span>[c]=(<span class="fstat-no" title="function not covered" >_=</span>&gt;{const g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return _.apply(this,Ae(arguments,i+"."+c))}</span>;<span class="cstat-no" title="statement not covered" ></span>return ae(g,_),g}</span>)(u)}</span>}</span>}</span>(e.navigator.geolocation,["getCurrentPosition","watchPosition"])}</span>),Zone.__load_patch("PromiseRejectionEvent",<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{function <span class="fstat-no" title="function not covered" >i(</span>r){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(c){<span class="cstat-no" title="statement not covered" >et(e,r).forEach(<span class="fstat-no" title="function not covered" >f=</span>&gt;{const _=<span class="cstat-no" title="statement not covered" >e.PromiseRejectionEvent;<span class="cstat-no" title="statement not covered" ></span>if(_){const g=<span class="cstat-no" title="statement not covered" >new _(r,{promise:c.promise,reason:c.rejection});<span class="cstat-no" title="statement not covered" ></span>f.invoke(g)}</span>}</span>)}</span>}<span class="cstat-no" title="statement not covered" ></span>e.PromiseRejectionEvent&amp;&amp;(n[x("unhandledPromiseRejectionHandler")]=i("unhandledrejection"),n[x("rejectionHandledHandler")]=i("rejectionhandled"))}</span>)}</span>,7344:<span class="fstat-no" title="function not covered" >(w</span>e,ue,he)=&gt;{<span class="cstat-no" title="statement not covered" >he(8782)}</span>},<span class="fstat-no" title="function not covered" >we</span>=&gt;{<span class="cstat-no" title="statement not covered" >we(we.s=7344)}</span>]);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Wed Nov 10 2021 20:49:09 GMT-0500 (Eastern Standard Time)
            </div>
        </div>
        <script src="../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../sorter.js"></script>
        <script src="../../../block-navigation.js"></script>
    </body>
</html>
    